<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geomaster: An Interactive Website for Geometric Constructions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1, h2 {
            color: #2c3e50;
        }

        .construction-method {
            margin-bottom: 30px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .step {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 3px;
        }

        .canvas-container {
            margin: 20px 0;
            text-align: center;
            position: relative;
            border: 2px solid #3498db;
            border-radius: 10px;
            background: #fff;
            padding: 10px;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: white;
            margin: 10px 0;
            cursor: crosshair;
        }

        .tools {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            position: relative;
            transition: all 0.3s ease;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #2c3e50;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 10;
        }

        .active-tool {
            background-color: #2c3e50;
            transform: scale(1.1);
        }

        .tool-active {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            font-style: italic;
            color: #7f8c8d;
            margin-top: 10px;
            text-align: center;
        }

        .protractor {
            position: absolute;
            width: 200px;
            height: 200px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><path d="M100 20 A80 80 0 0 1 180 100 L100 100 Z" fill="%23f1c40f" fill-opacity="0.3" stroke="%23f39c12" stroke-width="1"/><circle cx="100" cy="100" r="2" fill="%23e74c3c"/><text x="100" y="30" font-size="10" text-anchor="middle">0¬∞</text><text x="180" y="110" font-size="10" text-anchor="middle">90¬∞</text><text x="100" y="190" font-size="10" text-anchor="middle">180¬∞</text><text x="20" y="110" font-size="10" text-anchor="middle">-90¬∞</text><text x="140" y="40" font-size="8" text-anchor="middle">30¬∞</text><text x="160" y="60" font-size="8" text-anchor="middle">45¬∞</text><text x="170" y="85" font-size="8" text-anchor="middle">60¬∞</text><text x="60" y="40" font-size="8" text-anchor="middle">-30¬∞</text><text x="40" y="60" font-size="8" text-anchor="middle">-45¬∞</text><text x="30" y="85" font-size="8" text-anchor="middle">-60¬∞</text></svg>');
            pointer-events: none;
            display: none;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.1s;
        }

        .ruler {
            position: absolute;
            width: 200px;
            height: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="30"><rect width="200" height="30" fill="%23f9f9f9" stroke="%23333" stroke-width="1"/><line x1="0" y1="15" x2="200" y2="15" stroke="%23333" stroke-width="1"/><text x="10" y="10" font-size="8">0</text><text x="190" y="10" font-size="8">20</text><text x="100" y="10" font-size="8">10</text><line x1="20" y1="10" x2="20" y2="20" stroke="%23333" stroke-width="1"/><line x1="40" y1="10" x2="40" y2="20" stroke="%23333" stroke-width="1"/><line x1="60" y1="10" x2="60" y2="20" stroke="%23333" stroke-width="1"/><line x1="80" y1="10" x2="80" y2="20" stroke="%23333" stroke-width="1"/><line x1="120" y1="10" x2="120" y2="20" stroke="%23333" stroke-width="1"/><line x1="140" y1="10" x2="140" y2="20" stroke="%23333" stroke-width="1"/><line x1="160" y1="10" x2="160" y2="20" stroke="%23333" stroke-width="1"/><line x1="180" y1="10" x2="180" y2="20" stroke="%23333" stroke-width="1"/><line x1="5" y1="5" x2="5" y2="25" stroke="%23333" stroke-width="1"/><line x1="195" y1="5" x2="195" y2="25" stroke="%23333" stroke-width="1"/><line x1="50" y1="5" x2="50" y2="25" stroke="%23333" stroke-width="1"/><line x1="150" y1="5" x2="150" y2="25" stroke="%23333" stroke-width="1"/></svg>');
            pointer-events: none;
            display: none;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.1s;
        }

        .center-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #e74c3c;
            border-radius: 50%;
            z-index: 20;
            display: none;
            cursor: move;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2em;
        }

        .lesson-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .lesson-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .lesson-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .lesson-btn.active {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
        }

        .content-area {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
        }

        .lesson-content {
            display: none;
        }

        .lesson-content.active {
            display: block;
        }

        .lesson-title {
            color: #4CAF50;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .procedure-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 5px solid #4CAF50;
        }

        .procedure-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .steps {
            list-style: none;
            counter-reset: step-counter;
        }

        .steps li {
            counter-increment: step-counter;
            margin-bottom: 15px;
            padding-left: 40px;
            position: relative;
            line-height: 1.6;
        }

        .steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #4CAF50;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .quiz-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            color: white;
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .quiz-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .quiz-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .quiz-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .question-card {
            background: white;
            color: #333;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .question-number {
            background: #4CAF50;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 15px;
        }

        .question-text {
            font-size: 1.2em;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .options {
            display: grid;
            gap: 10px;
        }

        .option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .option:hover {
            background: #e7f3ff;
            border-color: #4CAF50;
        }

        .option.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .option.correct {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .option.incorrect {
            background: #f44336;
            color: white;
            border-color: #da190b;
        }

        .quiz-footer {
            text-align: center;
            margin-top: 30px;
        }

        .next-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .next-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        .next-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .score-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
        }

        .activity-section {
            background: #fff3cd;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            border-left: 5px solid #ffc107;
        }

        .activity-title {
            color: #856404;
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .final-score {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-size: 1.5em;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .lesson-selector {
                flex-direction: column;
                align-items: center;
            }

            .lesson-btn {
                width: 100%;
                max-width: 300px;
            }

            .quiz-controls {
                flex-direction: column;
                align-items: center;
            }

            .quiz-btn {
                width: 100%;
                max-width: 200px;
            }

            .canvas-container {
                padding: 5px;
            }

            canvas {
                width: 100%;
                height: auto;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî∫ Geomaster: An Interactive Website for Geometric Constructions</h1>
            <p>Master Triangle Construction & Perpendicular Bisectors with Interactive Tools</p>
        </div>

        <div class="tools">
            <button id="pointer-btn" data-tooltip="Select and move points/lines">Pointer</button>
            <button id="line-btn" data-tooltip="Draw straight lines">Line</button>
            <button id="point-btn" data-tooltip="Place labeled points">Point</button>
            <button id="freehand-btn" data-tooltip="Draw freehand lines">Freehand</button>
            <button id="protractor-btn" data-tooltip="Measure angles">Protractor</button>
            <button id="ruler-btn" data-tooltip="Measure lengths">Ruler</button>
            <button id="undo-btn" data-tooltip="Undo last action">Undo</button>
            <button id="clear-btn" data-tooltip="Clear canvas">Clear</button>
        </div>

        <div class="canvas-container">
            <canvas id="construction-canvas" width="800" height="500"></canvas>
            <div class="protractor" id="protractor"></div>
            <div class="ruler" id="ruler"></div>
            <div class="center-handle" id="protractor-handle"></div>
            <div class="center-handle" id="ruler-handle"></div>
        </div>
        <div class="instructions">Use the tools to construct geometric shapes. Press ESC to hide protractor/ruler.</div>

        <div class="lesson-selector">
            <button class="lesson-btn active" onclick="showLesson(1)">üìê Perpendicular Bisector</button>
            <button class="lesson-btn" onclick="showLesson(2)">üî∫ Triangle Construction (SSS, SAS, ASA)</button>
            <button class="lesson-btn" onclick="showLesson(3)">üìè Triangle from Side Lengths</button>
        </div>

        <div class="content-area">
            <!-- Lesson 1: Perpendicular Bisector -->
            <div id="lesson1" class="lesson-content active">
                <h2 class="lesson-title">Perpendicular Bisector</h2>
                <div class="procedure-section">
                    <h3>üìã Construction Procedure</h3>
                    <p><strong>Given:</strong> A line segment AB</p>
                    <ol class="steps">
                        <li>Draw the given line segment using a ruler and label the endpoints as A and B.</li>
                        <li>Place the compass at point A and open it to more than half of AB but less than its full length.</li>
                        <li>Draw an arc above and below the line.</li>
                        <li>Without changing the compass width, place it at point B and draw another arc above and below AB, ensuring these arcs intersect the first ones.</li>
                        <li>Mark the points of intersection of the arcs and label them as X and Y.</li>
                        <li>Draw a straight line through X and Y using a ruler. This line is the perpendicular bisector of AB.</li>
                        <li>Verify the construction: The bisector should divide AB into two equal parts and form a 90¬∞ angle with AB at the midpoint.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">üéØ Key Concepts</h3>
                    <ul>
                        <li><strong>Perpendicular:</strong> Forms a 90¬∞ angle with the original segment</li>
                        <li><strong>Bisector:</strong> Divides the segment into two equal parts</li>
                        <li><strong>Equidistant:</strong> Every point on the bisector is equidistant from both endpoints</li>
                        <li><strong>Applications:</strong> Finding centers, road construction, map navigation</li>
                    </ul>
                </div>
            </div>

            <!-- Lesson 2: Triangle Construction -->
            <div id="lesson2" class="lesson-content">
                <h2 class="lesson-title">Triangle Construction (SSS, SAS, ASA)</h2>
                <div class="procedure-section">
                    <h3>üìã SSS (Side-Side-Side) Construction</h3>
                    <ol class="steps">
                        <li>Draw the longest given side as the base using a ruler and label it AB.</li>
                        <li>Set the compass to the length of the second side, place it at A, and draw an arc.</li>
                        <li>Set the compass to the length of the third side, place it at B, and draw another arc that intersects the first arc.</li>
                        <li>Mark the intersection point as C. This is the third vertex of the triangle.</li>
                        <li>Connect points A, B, and C using a ruler to complete the triangle.</li>
                    </ol>
                </div>
                <div class="procedure-section">
                    <h3>üìã SAS (Side-Angle-Side) Construction</h3>
                    <ol class="steps">
                        <li>Draw the given side as the base using a ruler and label it AB.</li>
                        <li>Use a protractor at A to mark the given angle and draw a ray extending outward.</li>
                        <li>Set the compass to the length of the second given side, place it at A, and mark the second side's length on the ray.</li>
                        <li>Connect the new point to B to complete the triangle.</li>
                    </ol>
                </div>
                <div class="procedure-section">
                    <h3>üìã ASA (Angle-Side-Angle) Construction</h3>
                    <ol class="steps">
                        <li>Draw the given side as the base using a ruler and label it AB.</li>
                        <li>Use a protractor at A and B to mark the given angles and draw rays extending from these angles.</li>
                        <li>Find the intersection of the two rays and mark it as C.</li>
                        <li>Connect points A, B, and C using a ruler to complete the triangle.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">üéØ Key Concepts</h3>
                    <ul>
                        <li><strong>SSS:</strong> All three sides given - creates unique triangle</li>
                        <li><strong>SAS:</strong> Two sides and included angle - creates unique triangle</li>
                        <li><strong>ASA:</strong> Two angles and included side - creates unique triangle</li>
                        <li><strong>Triangle Inequality:</strong> Sum of any two sides must be greater than the third side</li>
                    </ul>
                </div>
            </div>

            <!-- Lesson 3: Triangle from Side Lengths -->
            <div id="lesson3" class="lesson-content">
                <h2 class="lesson-title">Constructing a Triangle Given Its Side Lengths</h2>
                <div class="procedure-section">
                    <h3>üìã Construction Procedure</h3>
                    <p><strong>Given:</strong> Three side lengths</p>
                    <ol class="steps">
                        <li>Draw the longest side first using a ruler and label it AB.</li>
                        <li>Set the compass to the second side length, place it at A, and draw an arc.</li>
                        <li>Set the compass to the third side length, place it at B, and draw another arc.</li>
                        <li>Mark the intersection of the arcs and label it as C.</li>
                        <li>Connect points A, B, and C using a ruler to complete the triangle.</li>
                        <li>Check if the triangle satisfies the triangle inequality theorem: the sum of any two sides must be greater than the third side.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">üéØ Triangle Inequality Theorem</h3>
                    <p>For any triangle with sides a, b, and c:</p>
                    <ul>
                        <li>a + b > c</li>
                        <li>a + c > b</li>
                        <li>b + c > a</li>
                    </ul>
                    <p>If any of these conditions are not met, the triangle cannot be constructed.</p>
                </div>
            </div>
        </div>

        <div class="quiz-section">
            <div class="quiz-header">
                <h2>üéÆ Interactive Quiz Game</h2>
                <p>Test your knowledge with shuffled questions!</p>
            </div>
            <div class="quiz-controls">
                <button class="quiz-btn" onclick="startQuiz(1)">Quiz: Perpendicular Bisector</button>
                <button class="quiz-btn" onclick="startQuiz(2)">Quiz: Triangle Construction</button>
                <button class="quiz-btn" onclick="startQuiz(3)">Quiz: Side Lengths</button>
                <button class="quiz-btn" onclick="startMixedQuiz()">Mixed Quiz</button>
            </div>
            <div id="quiz-container" style="display: none;">
                <div class="score-display">
                    <span id="score-text">Score: 0/0</span>
                </div>
                <div id="question-container"></div>
                <div class="quiz-footer">
                    <button id="next-btn" class="next-btn" onclick="nextQuestion()" disabled>Next Question</button>
                </div>
            </div>
            <div id="final-score" class="final-score" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Question data
        const questions = {
            1: [
                {
                    question: "What does a perpendicular bisector do to a line segment?",
                    options: ["Cuts it into two unequal parts", "Passes through its midpoint at a right angle", "Extends the segment indefinitely", "Connects the endpoints of the segment"],
                    correct: 1
                },
                {
                    question: "What tools are needed to construct a perpendicular bisector?",
                    options: ["Compass and protractor", "Compass and straightedge", "Ruler and protractor", "Grid paper and ruler"],
                    correct: 1
                },
                {
                    question: "How many points does a perpendicular bisector share with the original segment?",
                    options: ["One", "Two", "Infinite", "None"],
                    correct: 0
                },
                {
                    question: "When constructing a perpendicular bisector, what is the first step?",
                    options: ["Measure the segment with a ruler", "Draw arcs from both endpoints with the same radius", "Mark the midpoint using estimation", "Use a protractor to find the right angle"],
                    correct: 1
                },
                {
                    question: "The perpendicular bisector of a segment always passes through:",
                    options: ["One endpoint", "The midpoint", "A random point on the segment", "The longest side of a triangle"],
                    correct: 1
                },
                {
                    question: "What angle does the perpendicular bisector form with the original segment?",
                    options: ["30¬∞", "45¬∞", "60¬∞", "90¬∞"],
                    correct: 3
                },
                {
                    question: "Which of the following is true about the perpendicular bisector?",
                    options: ["It always lies inside the triangle", "It divides the segment into two equal parts", "It is always the longest side of a triangle", "It must pass through an endpoint"],
                    correct: 1
                },
                {
                    question: "What happens if the compass width is changed while constructing the perpendicular bisector?",
                    options: ["The bisector will be accurate", "The arcs will not intersect correctly", "The segment length will change", "The midpoint will shift"],
                    correct: 1
                },
                {
                    question: "In an isosceles triangle, the perpendicular bisector of the base also acts as the:",
                    options: ["Median", "Altitude", "Angle bisector", "All of the above"],
                    correct: 3
                },
                {
                    question: "What is a real-life application of a perpendicular bisector?",
                    options: ["Cutting wood into equal parts", "Measuring angles on a ramp", "Finding the shortest route between two points", "Drawing a curved path"],
                    correct: 0
                },
                {
                    question: "If a perpendicular bisector is drawn on a map between two cities, what does every point on it represent?",
                    options: ["The midpoint between the cities", "The shortest route between the cities", "Points equidistant from both cities", "The highest elevation on the map"],
                    correct: 2
                },
                {
                    question: "What shape is formed when perpendicular bisectors are drawn for all three sides of a triangle?",
                    options: ["A square", "A circumcircle", "A parallelogram", "A rhombus"],
                    correct: 1
                },
                {
                    question: "If two points lie on the perpendicular bisector of a segment, they are:",
                    options: ["Congruent", "Equidistant from the endpoints", "Midpoints of different segments", "Perpendicular to each other"],
                    correct: 1
                },
                {
                    question: "The point of intersection of the perpendicular bisectors of a triangle is called:",
                    options: ["Incenter", "Centroid", "Circumcenter", "Orthocenter"],
                    correct: 2
                },
                {
                    question: "The perpendicular bisector of a segment always divides it into:",
                    options: ["Two equal halves", "Two right triangles", "Two congruent circles", "Three unequal parts"],
                    correct: 0
                },
                {
                    question: "If a point is on the perpendicular bisector of a segment, then:",
                    options: ["It is closer to one endpoint", "It is equidistant from both endpoints", "It is the midpoint", "It is always inside the segment"],
                    correct: 1
                },
                {
                    question: "How can you check the accuracy of a perpendicular bisector construction?",
                    options: ["Measure both halves with a ruler", "Estimate by looking at it", "Use a protractor to check the angle", "Redraw the segment in a different location"],
                    correct: 0
                },
                {
                    question: "In an equilateral triangle, the perpendicular bisector of a side is also:",
                    options: ["A median", "An altitude", "An angle bisector", "All of the above"],
                    correct: 3
                },
                {
                    question: "When drawing a perpendicular bisector, what happens if the arcs do not intersect?",
                    options: ["The segment is too long", "The compass setting was incorrect", "The bisector is already drawn", "The straightedge is misplaced"],
                    correct: 1
                },
                {
                    question: "The perpendicular bisector theorem states that any point on the bisector is:",
                    options: ["Half the length of the segment", "Equidistant from the segment's endpoints", "A midpoint of a different segment", "Always located inside a triangle"],
                    correct: 1
                }
            ],
            2: [
                {
                    question: "Which of the following is NOT a valid triangle construction method?",
                    options: ["SSS (Side-Side-Side)", "SAS (Side-Angle-Side)", "SSA (Side-Side-Angle)", "ASA (Angle-Side-Angle)"],
                    correct: 2
                },
                {
                    question: "What tool is NOT essential for constructing triangles using SSS, SAS, or ASA?",
                    options: ["Compass", "Protractor", "Ruler", "Calculator"],
                    correct: 3
                },
                {
                    question: "In the SSS construction method, what must be given?",
                    options: ["Three angles", "Two sides and an angle", "Three sides", "Two angles and a side"],
                    correct: 2
                },
                {
                    question: "The SAS criterion requires:",
                    options: ["Three sides to be given", "Two sides and the included angle", "Two sides and a non-included angle", "Three angles"],
                    correct: 1
                },
                {
                    question: "In ASA construction, what is always included?",
                    options: ["Two angles and an included side", "Three sides", "Two angles and any side", "One angle and two sides"],
                    correct: 0
                },
                {
                    question: "When using SSS to construct a triangle, what is the first step?",
                    options: ["Draw a base using one of the given sides", "Estimate the shape of the triangle", "Draw all three sides at the same time", "Use a protractor to measure the angles"],
                    correct: 0
                },
                {
                    question: "Why is SSA not a valid triangle construction method?",
                    options: ["It always results in a right triangle", "It may lead to multiple possible triangles", "It does not use a protractor", "It does not consider side lengths"],
                    correct: 1
                },
                {
                    question: "What happens if the sum of two given sides is less than the third side?",
                    options: ["The triangle is obtuse", "The triangle is impossible to construct", "The triangle is always equilateral", "The angles must be recalculated"],
                    correct: 1
                },
                {
                    question: "Which of the following construction methods guarantees a unique triangle?",
                    options: ["SSA", "AAA", "SAS", "Any three angles"],
                    correct: 2
                },
                {
                    question: "A triangle with sides 5 cm, 7 cm, and 12 cm:",
                    options: ["Cannot be constructed", "Is always an isosceles triangle", "Must be a right triangle", "Is an equilateral triangle"],
                    correct: 0
                },
                {
                    question: "In triangle construction, the included angle refers to:",
                    options: ["The angle between two given sides", "Any angle inside the triangle", "The longest angle in the triangle", "A 90-degree angle"],
                    correct: 0
                },
                {
                    question: "What is the main advantage of using ASA for constructing a triangle?",
                    options: ["It does not require a protractor", "It allows quick estimation", "It ensures a unique triangle", "It does not require any sides"],
                    correct: 2
                },
                {
                    question: "If you are given an angle of 60¬∞, another angle of 40¬∞, and a side of 8 cm between them, which construction method is used?",
                    options: ["SSS", "SAS", "ASA", "SSA"],
                    correct: 2
                },
                {
                    question: "Which of the following is an incorrect triangle inequality condition?",
                    options: ["3 cm, 4 cm, 5 cm", "6 cm, 2 cm, 10 cm", "7 cm, 8 cm, 9 cm", "5 cm, 5 cm, 5 cm"],
                    correct: 1
                },
                {
                    question: "What real-life application requires constructing triangles using SSS, SAS, or ASA?",
                    options: ["Measuring time on a clock", "Designing bridges and trusses", "Cooking a recipe", "Estimating the height of a tree"],
                    correct: 1
                },
                {
                    question: "When constructing an SSS triangle, how do you determine the third vertex?",
                    options: ["By using a protractor", "By drawing two arcs that intersect", "By guessing its location", "By measuring it with a ruler"],
                    correct: 1
                },
                {
                    question: "If you construct a triangle using SAS, how do you determine the third side?",
                    options: ["Use a compass to locate the third vertex", "Extend the first two sides indefinitely", "Use a ruler to estimate the missing side", "Measure the side before drawing the triangle"],
                    correct: 0
                },
                {
                    question: "Which statement is always true for any triangle construction?",
                    options: ["The sum of any two sides must be greater than the third side", "At least one angle must be 90¬∞", "The longest side must be opposite the smallest angle", "All three sides must be equal"],
                    correct: 0
                },
                {
                    question: "If you construct a triangle using ASA, which tool is essential?",
                    options: ["Compass", "Protractor", "Scale", "Graph paper"],
                    correct: 1
                },
                {
                    question: "Which of the following triangle construction errors would result in an impossible triangle?",
                    options: ["The two given angles sum to more than 180¬∞", "The two given sides sum to be greater than the third side", "The included angle is measured incorrectly", "The third vertex is located incorrectly"],
                    correct: 0
                }
            ],
            3: [
                {
                    question: "What is the first step in constructing a triangle given its three side lengths?",
                    options: ["Draw any random triangle", "Measure and draw the longest side first", "Draw all three sides at the same time", "Use a protractor to measure angles"],
                    correct: 1
                },
                {
                    question: "Why should the longest side be drawn first in triangle construction?",
                    options: ["It is easier to measure angles from the longest side", "The longest side always forms a right triangle", "It prevents construction errors", "It helps ensure the triangle fits within the drawing space"],
                    correct: 3
                },
                {
                    question: "When using a compass to construct a triangle, what do the arcs represent?",
                    options: ["The angles of the triangle", "The possible locations of the third vertex", "The height of the triangle", "The midpoint of the triangle"],
                    correct: 1
                },
                {
                    question: "What condition must be met for three given sides to form a triangle?",
                    options: ["The longest side must be at least twice the shortest side", "The sum of any two sides must be greater than the third side", "The sides must be equal in length", "The difference between any two sides must be greater than the third side"],
                    correct: 1
                },
                {
                    question: "If given side lengths 4 cm, 5 cm, and 9 cm, what conclusion can be made?",
                    options: ["The triangle is equilateral", "The triangle is impossible to construct", "The triangle is always obtuse", "The triangle is always right-angled"],
                    correct: 1
                },
                {
                    question: "Which tool is NOT necessary when constructing a triangle given three side lengths?",
                    options: ["Compass", "Ruler", "Protractor", "Pencil"],
                    correct: 2
                },
                {
                    question: "What is the purpose of using a compass when constructing a triangle?",
                    options: ["To measure angles accurately", "To ensure all sides are equal", "To locate the exact position of the third vertex", "To check if the triangle is right-angled"],
                    correct: 2
                },
                {
                    question: "If you are given three side lengths and successfully construct a triangle, what is guaranteed?",
                    options: ["The triangle is always isosceles", "The triangle is unique", "The triangle must be a right triangle", "The triangle can have multiple possible shapes"],
                    correct: 1
                },
                {
                    question: "What happens if the sum of two given sides is exactly equal to the third side?",
                    options: ["A right triangle is formed", "A straight-line segment is formed, not a triangle", "A scalene triangle is formed", "A triangle with one 90¬∞ angle is formed"],
                    correct: 1
                },
                {
                    question: "Which of the following side lengths can form a triangle?",
                    options: ["2 cm, 3 cm, 6 cm", "5 cm, 5 cm, 10 cm", "7 cm, 8 cm, 12 cm", "4 cm, 4 cm, 9 cm"],
                    correct: 2
                },
                {
                    question: "What is the next step after drawing the longest side in triangle construction?",
                    options: ["Draw arcs from both endpoints using the other given side lengths", "Draw the other two sides without measuring", "Estimate the angles and complete the triangle", "Use a protractor to draw an angle before measuring sides"],
                    correct: 0
                },
                {
                    question: "Which triangle can be uniquely determined using just three side lengths?",
                    options: ["A right triangle", "A scalene triangle", "A triangle satisfying the triangle inequality theorem", "Any triangle with an angle sum of 180¬∞"],
                    correct: 2
                },
                {
                    question: "Why is it important to check the triangle inequality theorem before construction?",
                    options: ["To determine if the sides will form a valid triangle", "To ensure the triangle is equilateral", "To check if the angles add up to 180¬∞", "To confirm that one side is twice another side"],
                    correct: 0
                },
                {
                    question: "If a triangle is constructed with side lengths of 5 cm, 5 cm, and 8 cm, what type of triangle is it?",
                    options: ["Equilateral", "Isosceles", "Scalene", "Right-angled"],
                    correct: 1
                },
                {
                    question: "A real-life application of constructing triangles using given side lengths is:",
                    options: ["Estimating the area of a circle", "Designing a truss for a bridge", "Measuring time on a clock", "Constructing a rectangle"],
                    correct: 1
                },
                {
                    question: "What role does the compass play in triangle construction?",
                    options: ["It helps measure angles accurately", "It ensures the sides are parallel", "It determines the possible location of the third vertex", "It helps verify the length of the base"],
                    correct: 2
                },
                {
                    question: "A triangle has side lengths of 3 cm, 4 cm, and 5 cm. What special property does this triangle have?",
                    options: ["It is an obtuse triangle", "It is a right triangle", "It is an equilateral triangle", "It is an impossible triangle"],
                    correct: 1
                },
                {
                    question: "If a triangle has sides 6 cm, 8 cm, and 10 cm, which of the following is true?",
                    options: ["It is a right triangle", "It is an equilateral triangle", "It is impossible to construct", "It must have an obtuse angle"],
                    correct: 0
                },
                {
                    question: "If the arcs drawn from both endpoints do not intersect, what does this indicate?",
                    options: ["The given side lengths do not satisfy the triangle inequality", "The triangle is an isosceles triangle", "The triangle is obtuse", "The base length was measured incorrectly"],
                    correct: 0
                },
                {
                    question: "Which of the following errors would result in an inaccurate triangle construction?",
                    options: ["Using a compass to locate the third vertex", "Drawing the arcs too large or too small", "Checking the triangle inequality before construction", "Using a ruler to draw the base"],
                    correct: 1
                }
            ]
        };

        // Quiz variables
        let currentQuiz = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedAnswer = null;
        let quizActive = false;

        // Show lesson function
        function showLesson(lessonNum) {
            document.querySelectorAll('.lesson-content').forEach(lesson => {
                lesson.classList.remove('active');
            });
            document.getElementById(`lesson${lessonNum}`).classList.add('active');
            document.querySelectorAll('.lesson-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('final-score').style.display = 'none';
            quizActive = false;
        }

        // Shuffle array function
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Start quiz function
        function startQuiz(lessonNum) {
            currentQuiz = shuffleArray(questions[lessonNum]);
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;
            quizActive = true;
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('final-score').style.display = 'none';
            showQuestion();
        }

        // Start mixed quiz function
        function startMixedQuiz() {
            const allQuestions = [...questions[1], ...questions[2], ...questions[3]];
            currentQuiz = shuffleArray(allQuestions).slice(0, 20);
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;
            quizActive = true;
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('final-score').style.display = 'none';
            showQuestion();
        }

        // Show question function
        function showQuestion() {
            if (currentQuestionIndex >= currentQuiz.length) {
                showFinalScore();
                return;
            }

            const question = currentQuiz[currentQuestionIndex];
            const questionContainer = document.getElementById('question-container');
            questionContainer.innerHTML = `
                <div class="question-card fade-in">
                    <div class="question-number">Question ${currentQuestionIndex + 1} of ${currentQuiz.length}</div>
                    <div class="question-text">${question.question}</div>
                    <div class="options">
                        ${question.options.map((option, index) => `
                            <div class="option" onclick="selectAnswer(${index})">
                                <strong>${String.fromCharCode(65 + index)})</strong> ${option}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            document.getElementById('score-text').textContent = `Score: ${score}/${currentQuestionIndex}`;
            document.getElementById('next-btn').disabled = true;
            selectedAnswer = null;
        }

        // Select answer function
        function selectAnswer(answerIndex) {
            if (selectedAnswer !== null) return;
            selectedAnswer = answerIndex;
            const options = document.querySelectorAll('.option');
            const question = currentQuiz[currentQuestionIndex];
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === answerIndex && answerIndex !== question.correct) {
                    option.classList.add('incorrect');
                }
                option.style.pointerEvents = 'none';
            });
            if (answerIndex === question.correct) {
                score++;
            }
            document.getElementById('next-btn').disabled = false;
            setTimeout(() => {
                if (quizActive) {
                    nextQuestion();
                }
            }, 2000);
        }

        // Next question function
        function nextQuestion() {
            currentQuestionIndex++;
            showQuestion();
        }

        // Show final score function
        function showFinalScore() {
            document.getElementById('quiz-container').style.display = 'none';
            const percentage = Math.round((score / currentQuiz.length) * 100);
            let message = '';
            let emoji = '';
            if (percentage >= 90) {
                message = 'Excellent! You have mastered the concepts!';
                emoji = 'üèÜ';
            } else if (percentage >= 80) {
                message = 'Great job! You have a solid understanding!';
                emoji = 'üéâ';
            } else if (percentage >= 70) {
                message = 'Good work! Keep practicing to improve!';
                emoji = 'üëç';
            } else if (percentage >= 60) {
                message = 'Fair effort! Review the lessons and try again!';
                emoji = 'üìö';
            } else {
                message = 'Keep studying! Practice makes perfect!';
                emoji = 'üí™';
            }
            document.getElementById('final-score').innerHTML = `
                <div class="fade-in">
                    <h2>${emoji} Quiz Complete!</h2>
                    <p>Your Score: ${score}/${currentQuiz.length} (${percentage}%)</p>
                    <p>${message}</p>
                    <button class="quiz-btn" onclick="location.reload()" style="margin-top: 20px;">
                        üîÑ Try Again
                    </button>
                </div>
            `;
            document.getElementById('final-score').style.display = 'block';
            quizActive = false;
        }

        // Initialize the page
        document.addEventListener(' anna', function () {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('fade-in');
                    }
                });
            });
            document.querySelectorAll('.procedure-section, .activity-section').forEach(section => {
                observer.observe(section);
            });
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('construction-canvas');
            const ctx = canvas.getContext('2d');
            const protractor = document.getElementById('protractor');
            const ruler = document.getElementById('ruler');
            const protractorHandle = document.getElementById('protractor-handle');
            const rulerHandle = document.getElementById('ruler-handle');

            let currentTool = 'pointer';
            let isDrawing = false;
            let startX, startY;
            let points = [];
            let lines = [];
            let freehandPaths = [];
            let currentLine = null;
            let currentFreehandPath = null;
            let draggedElement = null;
            let protractorVisible = false;
            let rulerVisible = false;
            let protractorAngle = 0;
            let rulerAngle = 0;
            let isRotating = false;
            let actionHistory = [];

            // Tool buttons
            document.getElementById('pointer-btn').addEventListener('click', () => setTool('pointer'));
            document.getElementById('line-btn').addEventListener('click', () => setTool('line'));
            document.getElementById('point-btn').addEventListener('click', () => setTool('point'));
            document.getElementById('freehand-btn').addEventListener('click', () => setTool('freehand'));
            document.getElementById('protractor-btn').addEventListener('click', toggleProtractor);
            document.getElementById('ruler-btn').addEventListener('click', toggleRuler);
            document.getElementById('undo-btn').addEventListener('click', undoAction);
            document.getElementById('clear-btn').addEventListener('click', clearCanvas);

            function setTool(tool) {
                currentTool = tool;
                document.querySelectorAll('.tools button').forEach(btn => {
                    btn.classList.remove('active-tool');
                    btn.classList.remove('tool-active');
                });
                document.getElementById(`${tool}-btn`).classList.add('active-tool');
                protractorHandle.style.display = 'none';
                rulerHandle.style.display = 'none';
                canvas.style.cursor = tool === 'freehand' ? 'crosshair' : tool === 'point' ? 'crosshair' : tool === 'line' ? 'crosshair' : 'default';
            }

            function toggleProtractor() {
                protractorVisible = !protractorVisible;
                protractor.style.display = protractorVisible ? 'block' : 'none';
                document.getElementById('protractor-btn').classList.toggle('tool-active', protractorVisible);
                if (protractorVisible) {
                    setTool('protractor');
                    if (!protractor.style.left) {
                        const rect = canvas.getBoundingClientRect();
                        protractor.style.left = `${rect.width / 2 - 100}px`;
                        protractor.style.top = `${rect.height / 2 - 100}px`;
                    }
                    updateProtractorHandlePosition();
                    protractorHandle.style.display = 'block';
                } else {
                    setTool('pointer');
                }
            }

            function toggleRuler() {
                rulerVisible = !rulerVisible;
                ruler.style.display = rulerVisible ? 'block' : 'none';
                document.getElementById('ruler-btn').classList.toggle('tool-active', rulerVisible);
                if (rulerVisible) {
                    setTool('ruler');
                    if (!ruler.style.left) {
                        const rect = canvas.getBoundingClientRect();
                        ruler.style.left = `${rect.width / 2 - 100}px`;
                        ruler.style.top = `${rect.height / 2 - 15}px`;
                    }
                    updateRulerHandlePosition();
                    rulerHandle.style.display = 'block';
                } else {
                    setTool('pointer');
                }
            }

            function updateProtractorHandlePosition() {
                const protractorRect = protractor.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                protractorHandle.style.left = `${protractorRect.left + protractorRect.width / 2 - canvasRect.left - 6}px`;
                protractorHandle.style.top = `${protractorRect.top + protractorRect.height / 2 - canvasRect.top - 6}px`;
            }

            function updateRulerHandlePosition() {
                const rulerRect = ruler.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                rulerHandle.style.left = `${rulerRect.left + rulerRect.width / 2 - canvasRect.left - 6}px`;
                rulerHandle.style.top = `${rulerRect.top + rulerRect.height / 2 - canvasRect.top - 6}px`;
            }

            function clearCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                points = [];
                lines = [];
                freehandPaths = [];
                currentLine = null;
                currentFreehandPath = null;
                actionHistory = [];
                redrawCanvas();
            }

            function undoAction() {
                const action = actionHistory.pop();
                if (action) {
                    if (action.type === 'point') {
                        points.pop();
                    } else if (action.type === 'line') {
                        lines.pop();
                    } else if (action.type === 'freehand') {
                        freehandPaths.pop();
                    }
                    redrawCanvas();
                }
            }

            function drawPoint(x, y, label = '') {
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.stroke();
                if (label) {
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillText(label, x + 10, y + 5);
                }
            }

            function drawLine(x1, y1, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            function drawFreehandPath(path) {
                if (path.points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    ctx.lineTo(path.points[i].x, path.points[i].y);
                }
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                lines.forEach(line => drawLine(line.x1, line.y1, line.x2, line.y2));
                freehandPaths.forEach(path => drawFreehandPath(path));
                points.forEach(point => drawPoint(point.x, point.y, point.label));
                if (currentLine) {
                    drawLine(currentLine.x1, currentLine.y1, currentLine.x2, currentLine.y2);
                }
                if (currentFreehandPath) {
                    drawFreehandPath(currentFreehandPath);
                }
            }

            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function snapToPoint(x, y) {
                for (let point of points) {
                    const dx = x - point.x;
                    const dy = y - point.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 10) {
                        return { x: point.x, y: point.y };
                    }
                }
                return { x, y };
            }

            function isPointNearLine(x, y, line) {
                const A = x - line.x1;
                const B = y - line.y1;
                const C = line.x2 - line.x1;
                const D = line.y2 - line.y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq !== 0) {
                    param = dot / len_sq;
                }
                let xx, yy;
                if (param < 0) {
                    xx = line.x1;
                    yy = line.y1;
                } else if (param > 1) {
                    xx = line.x2;
                    yy = line.y2;
                } else {
                    xx = line.x1 + param * C;
                    yy = line.y1 + param * D;
                }
                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy) < 10;
            }

            function isPointNearPoint(x, y, point) {
                const dx = x - point.x;
                const dy = y - point.y;
                return Math.sqrt(dx * dx + dy * dy) < 10;
            }

            canvas.addEventListener('mousedown', function (e) {
                const mousePos = getMousePos(canvas, e);
                const snappedPos = snapToPoint(mousePos.x, mousePos.y);

                if (currentTool === 'pointer') {
                    for (let i = 0; i < lines.length; i++) {
                        if (isPointNearLine(mousePos.x, mousePos.y, lines[i])) {
                            draggedElement = { type: 'line', index: i, offsetX: mousePos.x - lines[i].x1, offsetY: mousePos.y - lines[i].y1 };
                            return;
                        }
                    }
                    for (let i = 0; i < points.length; i++) {
                        if (isPointNearPoint(mousePos.x, mousePos.y, points[i])) {
                            draggedElement = { type: 'point', index: i };
                            return;
                        }
                    }
                }

                if (currentTool === 'line') {
                    isDrawing = true;
                    startX = snappedPos.x;
                    startY = snappedPos.y;
                    currentLine = { x1: startX, y1: startY, x2: startX, y2: startY };
                }

                if (currentTool === 'point') {
                    points.push({ x: snappedPos.x, y: snappedPos.y, label: String.fromCharCode(65 + points.length) });
                    actionHistory.push({ type: 'point' });
                    redrawCanvas();
                }

                if (currentTool === 'freehand') {
                    isDrawing = true;
                    currentFreehandPath = { points: [{ x: snappedPos.x, y: snappedPos.y }] };
                }

                if (currentTool === 'protractor' && protractorVisible) {
                    const handleRect = protractorHandle.getBoundingClientRect();
                    const handleCenter = {
                        x: handleRect.left + handleRect.width / 2,
                        y: handleRect.top + handleRect.height / 2
                    };
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - handleCenter.x, 2) +
                        Math.pow(e.clientY - handleCenter.y, 2)
                    );
                    if (distance < 15) {
                        draggedElement = {
                            type: 'protractor-move',
                            startX: e.clientX,
                            startY: e.clientY,
                            initialLeft: parseFloat(protractor.style.left),
                            initialTop: parseFloat(protractor.style.top)
                        };
                        isRotating = false;
                    } else {
                        const protractorRect = protractor.getBoundingClientRect();
                        const protractorCenter = {
                            x: protractorRect.left + protractorRect.width / 2,
                            y: protractorRect.top + protractorRect.height / 2
                        };
                        const angle = Math.atan2(
                            e.clientY - protractorCenter.y,
                            e.clientX - protractorCenter.x
                        );
                        draggedElement = {
                            type: 'protractor-rotate',
                            startAngle: angle,
                            initialRotation: protractorAngle
                        };
                        isRotating = true;
                    }
                }

                if (currentTool === 'ruler' && rulerVisible) {
                    const handleRect = rulerHandle.getBoundingClientRect();
                    const handleCenter = {
                        x: handleRect.left + handleRect.width / 2,
                        y: handleRect.top + handleRect.height / 2
                    };
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - handleCenter.x, 2) +
                        Math.pow(e.clientY - handleCenter.y, 2)
                    );
                    if (distance < 15) {
                        draggedElement = {
                            type: 'ruler-move',
                            startX: e.clientX,
                            startY: e.clientY,
                            initialLeft: parseFloat(ruler.style.left),
                            initialTop: parseFloat(ruler.style.top)
                        };
                        isRotating = false;
                    } else {
                        const rulerRect = ruler.getBoundingClientRect();
                        const rulerCenter = {
                            x: rulerRect.left + rulerRect.width / 2,
                            y: rulerRect.top + rulerRect.height / 2
                        };
                        const angle = Math.atan2(
                            e.clientY - rulerCenter.y,
                            e.clientX - rulerCenter.x
                        );
                        draggedElement = {
                            type: 'ruler-rotate',
                            startAngle: angle,
                            initialRotation: rulerAngle
                        };
                        isRotating = true;
                    }
                }
            });

            canvas.addEventListener('mousemove', function (e) {
                const mousePos = getMousePos(canvas, e);
                const snappedPos = snapToPoint(mousePos.x, mousePos.y);

                if (currentTool === 'pointer' && draggedElement) {
                    if (draggedElement.type === 'line') {
                        const line = lines[draggedElement.index];
                        const dx = mousePos.x - draggedElement.offsetX - line.x1;
                        const dy = mousePos.y - draggedElement.offsetY - line.y1;
                        line.x1 += dx;
                        line.y1 += dy;
                        line.x2 += dx;
                        line.y2 += dy;
                        redrawCanvas();
                    } else if (draggedElement.type === 'point') {
                        points[draggedElement.index].x = snappedPos.x;
                        points[draggedElement.index].y = snappedPos.y;
                        redrawCanvas();
                    }
                    return;
                }

                if (currentTool === 'line' && isDrawing) {
                    currentLine.x2 = snappedPos.x;
                    currentLine.y2 = snappedPos.y;
                    redrawCanvas();
                }

                if (currentTool === 'freehand' && isDrawing) {
                    currentFreehandPath.points.push({ x: mousePos.x, y: mousePos.y });
                    redrawCanvas();
                }

                if (currentTool === 'protractor' && protractorVisible && draggedElement) {
                    if (draggedElement.type === 'protractor-move') {
                        const dx = e.clientX - draggedElement.startX;
                        const dy = e.clientY - draggedElement.startY;
                        protractor.style.left = `${draggedElement.initialLeft + dx}px`;
                        protractor.style.top = `${draggedElement.initialTop + dy}px`;
                        updateProtractorHandlePosition();
                    } else if (draggedElement.type === 'protractor-rotate') {
                        const protractorRect = protractor.getBoundingClientRect();
                        const protractorCenter = {
                            x: protractorRect.left + protractorRect.width / 2,
                            y: protractorRect.top + protractorRect.height / 2
                        };
                        const currentAngle = Math.atan2(
                            e.clientY - protractorCenter.y,
                            e.clientX - protractorCenter.x
                        );
                        const angleDiff = currentAngle - draggedElement.startAngle;
                        protractorAngle = draggedElement.initialRotation + angleDiff * (180 / Math.PI);
                        protractor.style.transform = `rotate(${protractorAngle}deg)`;
                        updateProtractorHandlePosition();
                    }
                }

                if (currentTool === 'ruler' && rulerVisible && draggedElement) {
                    if (draggedElement.type === 'ruler-move') {
                        const dx = e.clientX - draggedElement.startX;
                        const dy = e.clientY - draggedElement.startY;
                        ruler.style.left = `${draggedElement.initialLeft + dx}px`;
                        ruler.style.top = `${draggedElement.initialTop + dy}px`;
                        updateRulerHandlePosition();
                    } else if (draggedElement.type === 'ruler-rotate') {
                        const rulerRect = ruler.getBoundingClientRect();
                        const rulerCenter = {
                            x: rulerRect.left + rulerRect.width / 2,
                            y: rulerRect.top + rulerRect.height / 2
                        };
                        const currentAngle = Math.atan2(
                            e.clientY - rulerCenter.y,
                            e.clientX - rulerCenter.x
                        );
                        const angleDiff = currentAngle - draggedElement.startAngle;
                        rulerAngle = draggedElement.initialRotation + angleDiff * (180 / Math.PI);
                        ruler.style.transform = `rotate(${rulerAngle}deg)`;
                        updateRulerHandlePosition();
                    }
                }
            });

            canvas.addEventListener('mouseup', function (e) {
                const mousePos = getMousePos(canvas, e);
                const snappedPos = snapToPoint(mousePos.x, mousePos.y);

                if (currentTool === 'pointer' && draggedElement) {
                    draggedElement = null;
                    return;
                }

                if (currentTool === 'line' && isDrawing) {
                    isDrawing = false;
                    currentLine.x2 = snappedPos.x;
                    currentLine.y2 = snappedPos.y;
                    lines.push(currentLine);
                    actionHistory.push({ type: 'line' });
                    currentLine = null;
                    redrawCanvas();
                }

                if (currentTool === 'freehand' && isDrawing) {
                    isDrawing = false;
                    freehandPaths.push(currentFreehandPath);
                    actionHistory.push({ type: 'freehand' });
                    currentFreehandPath = null;
                    redrawCanvas();
                }

                if ((currentTool === 'protractor' || currentTool === 'ruler') && draggedElement) {
                    draggedElement = null;
                    isRotating = false;
                }
            });

            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    if (protractorVisible) toggleProtractor();
                    if (rulerVisible) toggleRuler();
                } else if (e.ctrlKey && e.key === 'z') {
                    undoAction();
                }
            });

            // Initialize with pointer tool active
            setTool('pointer');

            // Adjust canvas size for mobile
            function resizeCanvas() {
                if (window.innerWidth < 768) {
                    canvas.width = window.innerWidth - 40;
                    canvas.height = Math.min(400, window.innerHeight - 200);
                } else {
                    canvas.width = 800;
                    canvas.height = 500;
                }
                redrawCanvas();
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        });
    </script>
</body>
</html>