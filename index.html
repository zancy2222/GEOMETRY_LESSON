<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geomaster: An Interactive Website for Geometric Constructions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1, h2 {
            color: #2c3e50;
        }

        .construction-method {
            margin-bottom: 30px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .step {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 3px;
        }

        .canvas-container {
            margin: 20px 0;
            text-align: center;
            position: relative;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: white;
            margin: 10px 0;
        }

        .tools {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #2980b9;
        }

        .active-tool {
            background-color: #2c3e50;
        }

        .tool-active {
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            font-style: italic;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .protractor {
            position: absolute;
            width: 200px;
            height: 200px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><path d="M100 20 A80 80 0 0 1 180 100 L100 100 Z" fill="%23f1c40f" fill-opacity="0.3" stroke="%23f39c12" stroke-width="1"/><circle cx="100" cy="100" r="2" fill="%23e74c3c"/><text x="100" y="30" font-size="10" text-anchor="middle">0°</text><text x="180" y="110" font-size="10" text-anchor="middle">90°</text><text x="100" y="190" font-size="10" text-anchor="middle">180°</text><text x="20" y="110" font-size="10" text-anchor="middle">-90°</text><text x="140" y="40" font-size="8" text-anchor="middle">30°</text><text x="160" y="60" font-size="8" text-anchor="middle">45°</text><text x="170" y="85" font-size="8" text-anchor="middle">60°</text><text x="60" y="40" font-size="8" text-anchor="middle">-30°</text><text x="40" y="60" font-size="8" text-anchor="middle">-45°</text><text x="30" y="85" font-size="8" text-anchor="middle">-60°</text></svg>');
            pointer-events: none;
            display: none;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.1s;
        }

        .ruler {
            position: absolute;
            width: 200px;
            height: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="30"><rect width="200" height="30" fill="%23f9f9f9" stroke="%23333" stroke-width="1"/><line x1="0" y1="15" x2="200" y2="15" stroke="%23333" stroke-width="1"/><text x="10" y="10" font-size="8">0</text><text x="190" y="10" font-size="8">20</text><text x="100" y="10" font-size="8">10</text><line x1="20" y1="10" x2="20" y2="20" stroke="%23333" stroke-width="1"/><line x1="40" y1="10" x2="40" y2="20" stroke="%23333" stroke-width="1"/><line x1="60" y1="10" x2="60" y2="20" stroke="%23333" stroke-width="1"/><line x1="80" y1="10" x2="80" y2="20" stroke="%23333" stroke-width="1"/><line x1="120" y1="10" x2="120" y2="20" stroke="%23333" stroke-width="1"/><line x1="140" y1="10" x2="140" y2="20" stroke="%23333" stroke-width="1"/><line x1="160" y1="10" x2="160" y2="20" stroke="%23333" stroke-width="1"/><line x1="180" y1="10" x2="180" y2="20" stroke="%23333" stroke-width="1"/><line x1="5" y1="5" x2="5" y2="25" stroke="%23333" stroke-width="1"/><line x1="195" y1="5" x2="195" y2="25" stroke="%23333" stroke-width="1"/><line x1="50" y1="5" x2="50" y2="25" stroke="%23333" stroke-width="1"/><line x1="150" y1="5" x2="150" y2="25" stroke="%23333" stroke-width="1"/></svg>');
            pointer-events: none;
            display: none;
            z-index: 10;
            transform-origin: center;
            transition: transform 0.1s;
        }

        .compass {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(52, 152, 219, 0.5);
            border-radius: 50%;
            border: 2px solid #3498db;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .center-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            z-index: 20;
            display: none;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2em;
        }

        .lesson-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .lesson-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .lesson-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .lesson-btn.active {
            background: linear-gradient(45deg, #FF6B6B, #ee5a52);
        }

        .content-area {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
        }

        .lesson-content {
            display: none;
        }

        .lesson-content.active {
            display: block;
        }

        .lesson-title {
            color: #4CAF50;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .procedure-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border-left: 5px solid #4CAF50;
        }

        .procedure-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .steps {
            list-style: none;
            counter-reset: step-counter;
        }

        .steps li {
            counter-increment: step-counter;
            margin-bottom: 15px;
            padding-left: 40px;
            position: relative;
            line-height: 1.6;
        }

        .steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #4CAF50;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .quiz-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            color: white;
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .quiz-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .quiz-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .quiz-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .question-card {
            background: white;
            color: #333;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .question-number {
            background: #4CAF50;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 15px;
        }

        .question-text {
            font-size: 1.2em;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .options {
            display: grid;
            gap: 10px;
        }

        .option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .option:hover {
            background: #e7f3ff;
            border-color: #4CAF50;
        }

        .option.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .option.correct {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .option.incorrect {
            background: #f44336;
            color: white;
            border-color: #da190b;
        }

        .quiz-footer {
            text-align: center;
            margin-top: 30px;
        }

        .next-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .next-btn:hover:not(:disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        .next-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .score-display {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
        }

        .activity-section {
            background: #fff3cd;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            border-left: 5px solid #ffc107;
        }

        .activity-title {
            color: #856404;
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .final-score {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-size: 1.5em;
            margin-top: 20px;
        }

        .construction-feedback {
            background: #e9f7ef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .construction-feedback.show {
            display: block;
        }

        .construction-feedback.success {
            border-left: 5px solid #4CAF50;
        }

        .construction-feedback.error {
            border-left: 5px solid #f44336;
        }

        .construction-guide {
            background: #f0f4f8;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #34495e;
        }

        @media (max-width: 768px) {
            .lesson-selector {
                flex-direction: column;
                align-items: center;
            }

            .lesson-btn {
                width: 100%;
                max-width: 300px;
            }

            .quiz-controls {
                flex-direction: column;
                align-items: center;
            }

            .quiz-btn {
                width: 100%;
                max-width: 200px;
            }

            canvas {
                width: 100%;
                height: 400px;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔺 Geomaster: An Interactive Website for Geometric Constructions</h1>
            <p>Master Geometric Constructions with Interactive Tools</p>
        </div>

        <div class="tools">
            <button id="pointer-btn">Pointer</button>
            <button id="line-btn">Line</button>
            <button id="point-btn">Point</button>
            <button id="compass-btn">Compass</button>
            <button id="protractor-btn">Protractor</button>
            <button id="ruler-btn">Ruler</button>
             <button id="clear-btn">Clear</button>
        </div>

        <div class="canvas-container">
            <canvas id="construction-canvas" width="800" height="500"></canvas>
            <div class="protractor" id="protractor"></div>
            <div class="ruler" id="ruler"></div>
            <div class="compass" id="compass"></div>
            <div class="center-handle" id="protractor-handle"></div>
            <div class="center-handle" id="ruler-handle"></div>
            <div class="center-handle" id="compass-handle"></div>
          </div>

        <div class="lesson-selector">
            <button class="lesson-btn active" onclick="showLesson(1)">📐 Perpendicular Bisector</button>
            <button class="lesson-btn" onclick="showLesson(2)">🔺 Triangle Construction (SSS, SAS, ASA)</button>
            <button class="lesson-btn" onclick="showLesson(3)">📏 Triangle from Side Lengths</button>
        </div>

        <div class="content-area">
            <div id="lesson1" class="lesson-content active">
                <h2 class="lesson-title">Perpendicular Bisector</h2>
                <div class="procedure-section">
                    <h3>📋 Construction Procedure</h3>
                    <p><strong>Goal:</strong> Construct a line that bisects segment AB at a 90° angle</p>
                    <ol class="steps">
                        <li>Draw a line segment and label its endpoints as A and B.</li>
                        <li>Use the compass tool to set a radius greater than half of AB's length.</li>
                        <li>Place the compass at point A and draw two arcs (above and below the segment).</li>
                        <li>Without changing the compass width, place it at point B and draw two arcs intersecting the previous arcs.</li>
                        <li>Label the intersection points as X and Y.</li>
                        <li>Draw a line through X and Y using the line tool. This is the perpendicular bisector.</li>
                        <li>Click "Check Construction" to verify your work.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">🎯 Key Concepts</h3>
                    <ul>
                        <li><strong>Perpendicular:</strong> Forms a 90° angle with the original segment</li>
                        <li><strong>Bisector:</strong> Divides the segment into two equal parts</li>
                        <li><strong>Equidistant:</strong> Every point on the bisector is equidistant from both endpoints</li>
                        <li><strong>Applications:</strong> Finding centers, road construction, map navigation</li>
                    </ul>
                </div>
            </div>

            <div id="lesson2" class="lesson-content">
                <h2 class="lesson-title">Triangle Construction (SSS, SAS, ASA)</h2>
                <div class="procedure-section">
                    <h3>📋 SSS (Side-Side-Side) Construction</h3>
                    <ol class="steps">
                        <li>Draw the longest side using the ruler and label it AB.</li>
                        <li>Set the compass to the second side length, place it at A, and draw an arc.</li>
                        <li>Set the compass to the third side length, place it at B, and draw an arc intersecting the first arc.</li>
                        <li>Label the intersection as C.</li>
                        <li>Connect A, B, and C using the line tool.</li>
                        <li>Click "Check Construction" to verify.</li>
                    </ol>
                </div>
                <div class="procedure-section">
                    <h3>📋 SAS (Side-Angle-Side) Construction</h3>
                    <ol class="steps">
                        <li>Draw a side using the ruler and label it AB.</li>
                        <li>Use the protractor at A to mark the given angle and draw a ray.</li>
                        <li>Set the compass to the second side length, place it at A, and mark a point on the ray (C).</li>
                        <li>Connect C to B using the line tool.</li>
                        <li>Click "Check Construction" to verify.</li>
                    </ol>
                </div>
                <div class="procedure-section">
                    <h3>📋 ASA (Angle-Side-Angle) Construction</h3>
                    <ol class="steps">
                        <li>Draw a side using the ruler and label it AB.</li>
                        <li>Use the protractor at A and B to mark the given angles and draw rays.</li>
                        <li>Label the rays' intersection as C.</li>
                        <li>Connect A, B, and C using the line tool.</li>
                        <li>Click "Check Construction" to verify.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">🎯 Key Concepts</h3>
                    <ul>
                        <li><strong>SSS:</strong> All three sides given - creates unique triangle</li>
                        <li><strong>SAS:</strong> Two sides and included angle - creates unique triangle</li>
                        <li><strong>ASA:</strong> Two angles and included side - creates unique triangle</li>
                        <li><strong>Triangle Inequality:</strong> Sum of any two sides must be greater than the third side</li>
                    </ul>
                </div>
            </div>

            <div id="lesson3" class="lesson-content">
                <h2 class="lesson-title">Constructing a Triangle Given Its Side Lengths</h2>
                <div class="procedure-section">
                    <h3>📋 Construction Procedure</h3>
                    <p><strong>Given:</strong> Three side lengths (e.g., 6cm, 8cm, 10cm)</p>
                    <ol class="steps">
                        <li>Draw the longest side using the ruler and label it AB.</li>
                        <li>Set the compass to the second side length, place it at A, and draw an arc.</li>
                        <li>Set the compass to the third side length, place it at B, and draw an arc intersecting the first arc.</li>
                        <li>Label the intersection as C.</li>
                        <li>Connect A, B, and C using the line tool.</li>
                        <li>Click "Check Construction" to verify.</li>
                    </ol>
                </div>
                <div class="activity-section">
                    <h3 class="activity-title">🎯 Triangle Inequality Theorem</h3>
                    <p>For any triangle with sides a, b, and c:</p>
                    <ul>
                        <li>a + b > c</li>
                        <li>a + c > b</li>
                        <li>b + c > a</li>
                    </ul>
                    <p>If any condition fails, the triangle cannot be constructed.</p>
                </div>
            </div>
        </div>

        <div class="quiz-section">
            <div class="quiz-header">
                <h2>🎮 Interactive Quiz Game</h2>
                <p>Test your geometry knowledge with engaging quizzes!</p>
            </div>
            <div class="quiz-controls">
                <button class="quiz-btn" onclick="startQuiz(1)">Quiz: Perpendicular Bisector</button>
                <button class="quiz-btn" onclick="startQuiz(2)">Quiz: Triangle Construction</button>
                <button class="quiz-btn" onclick="startQuiz(3)">Quiz: Side Lengths</button>
                <button class="quiz-btn" onclick="startMixedQuiz()">Mixed Quiz</button>
            </div>
            <div id="quiz-container" style="display: none;">
                <div class="score-display">
                    <span id="score-text">Score: 0/0</span>
                </div>
                <div id="question-container"></div>
                <div class="quiz-footer">
                    <button id="next-btn" class="next-btn" onclick="nextQuestion()" disabled>Next Question</button>
                </div>
            </div>
            <div id="final-score" class="final-score" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Question data (unchanged)
        const questions = {
            1: [
                {
                    question: "What does a perpendicular bisector do to a line segment?",
                    options: ["Cuts it into two unequal parts", "Passes through its midpoint at a right angle", "Extends the segment indefinitely", "Connects the endpoints of the segment"],
                    correct: 1
                },
                {
                    question: "What tools are needed to construct a perpendicular bisector?",
                    options: ["Compass and protractor", "Compass and straightedge", "Ruler and protractor", "Grid paper and ruler"],
                    correct: 1
                },
                {
                    question: "How many points does a perpendicular bisector share with the original segment?",
                    options: ["One", "Two", "Infinite", "None"],
                    correct: 0
                },
                {
                    question: "When constructing a perpendicular bisector, what is the first step?",
                    options: ["Measure the segment with a ruler", "Draw arcs from both endpoints with the same radius", "Mark the midpoint using estimation", "Use a protractor to find the right angle"],
                    correct: 1
                },
                {
                    question: "The perpendicular bisector of a segment always passes through:",
                    options: ["One endpoint", "The midpoint", "A random point on the segment", "The longest side of a triangle"],
                    correct: 1
                },
                {
                    question: "What angle does the perpendicular bisector form with the original segment?",
                    options: ["30°", "45°", "60°", "90°"],
                    correct: 3
                },
                {
                    question: "Which of the following is true about the perpendicular bisector?",
                    options: ["It always lies inside the triangle", "It divides the segment into two equal parts", "It is always the longest side of a triangle", "It must pass through an endpoint"],
                    correct: 1
                },
                {
                    question: "What happens if the compass width is changed while constructing the perpendicular bisector?",
                    options: ["The bisector will be accurate", "The arcs will not intersect correctly", "The segment length will change", "The midpoint will shift"],
                    correct: 1
                },
                {
                    question: "In an isosceles triangle, the perpendicular bisector of the base also acts as the:",
                    options: ["Median", "Altitude", "Angle bisector", "All of the above"],
                    correct: 3
                },
                {
                    question: "What is a real-life application of a perpendicular bisector?",
                    options: ["Cutting wood into equal parts", "Measuring angles on a ramp", "Finding the shortest route between two points", "Drawing a curved path"],
                    correct: 0
                },
                {
                    question: "If a perpendicular bisector is drawn on a map between two cities, what does every point on it represent?",
                    options: ["The midpoint between the cities", "The shortest route between the cities", "Points equidistant from both cities", "The highest elevation on the map"],
                    correct: 2
                },
                {
                    question: "What shape is formed when perpendicular bisectors are drawn for all three sides of a triangle?",
                    options: ["A square", "A circumcircle", "A parallelogram", "A rhombus"],
                    correct: 1
                },
                {
                    question: "If two points lie on the perpendicular bisector of a segment, they are:",
                    options: ["Congruent", "Equidistant from the endpoints", "Midpoints of different segments", "Perpendicular to each other"],
                    correct: 1
                },
                {
                    question: "The point of intersection of the perpendicular bisectors of a triangle is called:",
                    options: ["Incenter", "Centroid", "Circumcenter", "Orthocenter"],
                    correct: 2
                },
                {
                    question: "The perpendicular bisector of a segment always divides it into:",
                    options: ["Two equal halves", "Two right triangles", "Two congruent circles", "Three unequal parts"],
                    correct: 0
                },
                {
                    question: "If a point is on the perpendicular bisector of a segment, then:",
                    options: ["It is closer to one endpoint", "It is equidistant from both endpoints", "It is the midpoint", "It is always inside the segment"],
                    correct: 1
                },
                {
                    question: "How can you check the accuracy of a perpendicular bisector construction?",
                    options: ["Measure both halves with a ruler", "Estimate by looking at it", "Use a protractor to check the angle", "Redraw the segment in a different location"],
                    correct: 0
                },
                {
                    question: "In an equilateral triangle, the perpendicular bisector of a side is also:",
                    options: ["A median", "An altitude", "An angle bisector", "All of the above"],
                    correct: 3
                },
                {
                    question: "When drawing a perpendicular bisector, what happens if the arcs do not intersect?",
                    options: ["The segment is too long", "The compass setting was incorrect", "The bisector is already drawn", "The straightedge is misplaced"],
                    correct: 1
                },
                {
                    question: "The perpendicular bisector theorem states that any point on the bisector is:",
                    options: ["Half the length of the segment", "Equidistant from the segment's endpoints", "A midpoint of a different segment", "Always located inside a triangle"],
                    correct: 1
                }
            ],
            2: [
                {
                    question: "Which of the following is NOT a valid triangle construction method?",
                    options: ["SSS (Side-Side-Side)", "SAS (Side-Angle-Side)", "SSA (Side-Side-Angle)", "ASA (Angle-Side-Angle)"],
                    correct: 2
                },
                {
                    question: "What tool is NOT essential for constructing triangles using SSS, SAS, or ASA?",
                    options: ["Compass", "Protractor", "Ruler", "Calculator"],
                    correct: 3
                },
                {
                    question: "In the SSS construction method, what must be given?",
                    options: ["Three angles", "Two sides and an angle", "Three sides", "Two angles and a side"],
                    correct: 2
                },
                {
                    question: "The SAS criterion requires:",
                    options: ["Three sides to be given", "Two sides and the included angle", "Two sides and a non-included angle", "Three angles"],
                    correct: 1
                },
                {
                    question: "In ASA construction, what is always included?",
                    options: ["Two angles and an included side", "Three sides", "Two angles and any side", "One angle and two sides"],
                    correct: 0
                },
                {
                    question: "When using SSS to construct a triangle, what is the first step?",
                    options: ["Draw a base using one of the given sides", "Estimate the shape of the triangle", "Draw all three sides at the same time", "Use a protractor to measure the angles"],
                    correct: 0
                },
                {
                    question: "Why is SSA not a valid triangle construction method?",
                    options: ["It always results in a right triangle", "It may lead to multiple possible triangles", "It does not use a protractor", "It does not consider side lengths"],
                    correct: 1
                },
                {
                    question: "What happens if the sum of two given sides is less than the third side?",
                    options: ["The triangle is obtuse", "The triangle is impossible to construct", "The triangle is always equilateral", "The angles must be recalculated"],
                    correct: 1
                },
                {
                    question: "Which of the following construction methods guarantees a unique triangle?",
                    options: ["SSA", "AAA", "SAS", "Any three angles"],
                    correct: 2
                },
                {
                    question: "A triangle with sides 5 cm, 7 cm, and 12 cm:",
                    options: ["Cannot be constructed", "Is always an isosceles triangle", "Must be a right triangle", "Is an equilateral triangle"],
                    correct: 0
                },
                {
                    question: "In triangle construction, the included angle refers to:",
                    options: ["The angle between two given sides", "Any angle inside the triangle", "The longest angle in the triangle", "A 90-degree angle"],
                    correct: 0
                },
                {
                    question: "What is the main advantage of using ASA for constructing a triangle?",
                    options: ["It does not require a protractor", "It allows quick estimation", "It ensures a unique triangle", "It does not require any sides"],
                    correct: 2
                },
                {
                    question: "If you are given an angle of 60°, another angle of 40°, and a side of 8 cm between them, which construction method is used?",
                    options: ["SSS", "SAS", "ASA", "SSA"],
                    correct: 2
                },
                {
                    question: "Which of the following is an incorrect triangle inequality condition?",
                    options: ["3 cm, 4 cm, 5 cm", "6 cm, 2 cm, 10 cm", "7 cm, 8 cm, 9 cm", "5 cm, 5 cm, 5 cm"],
                    correct: 1
                },
                {
                    question: "What real-life application requires constructing triangles using SSS, SAS, or ASA?",
                    options: ["Measuring time on a clock", "Designing bridges and trusses", "Cooking a recipe", "Estimating the height of a tree"],
                    correct: 1
                },
                {
                    question: "When constructing an SSS triangle, how do you determine the third vertex?",
                    options: ["By using a protractor", "By drawing two arcs that intersect", "By guessing its location", "By measuring it with a ruler"],
                    correct: 1
                },
                {
                    question: "If you construct a triangle using SAS, how do you determine the third side?",
                    options: ["Use a compass to locate the third vertex", "Extend the first two sides indefinitely", "Use a ruler to estimate the missing side", "Measure the side before drawing the triangle"],
                    correct: 0
                },
                {
                    question: "Which statement is always true for any triangle construction?",
                    options: ["The sum of any two sides must be greater than the third side", "At least one angle must be 90°", "The longest side must be opposite the smallest angle", "All three sides must be equal"],
                    correct: 0
                },
                {
                    question: "If you construct a triangle using ASA, which tool is essential?",
                    options: ["Compass", "Protractor", "Scale", "Graph paper"],
                    correct: 1
                },
                {
                    question: "Which of the following triangle construction errors would result in an impossible triangle?",
                    options: ["The two given angles sum to more than 180°", "The two given sides sum to be greater than the third side", "The included angle is measured incorrectly", "The third vertex is located incorrectly"],
                    correct: 0
                }
            ],
            3: [
                {
                    question: "What is the first step in constructing a triangle given its three side lengths?",
                    options: ["Draw any random triangle", "Measure and draw the longest side first", "Draw all three sides at the same time", "Use a protractor to measure angles"],
                    correct: 1
                },
                {
                    question: "Why should the longest side be drawn first in triangle construction?",
                    options: ["It is easier to measure angles from the longest side", "The longest side always forms a right triangle", "It prevents construction errors", "It helps ensure the triangle fits within the drawing space"],
                    correct: 3
                },
                {
                    question: "When using a compass to construct a triangle, what do the arcs represent?",
                    options: ["The angles of the triangle", "The possible locations of the third vertex", "The height of the triangle", "The midpoint of the triangle"],
                    correct: 1
                },
                {
                    question: "What condition must be met for three given sides to form a triangle?",
                    options: ["The longest side must be at least twice the shortest side", "The sum of any two sides must be greater than the third side", "The sides must be equal in length", "The difference between any two sides must be greater than the third side"],
                    correct: 1
                },
                {
                    question: "If given side lengths 4 cm, 5 cm, and 9 cm, what conclusion can be made?",
                    options: ["The triangle is equilateral", "The triangle is impossible to construct", "The triangle is always obtuse", "The triangle is always right-angled"],
                    correct: 1
                },
                {
                    question: "Which tool is NOT necessary when constructing a triangle given three side lengths?",
                    options: ["Compass", "Ruler", "Protractor", "Pencil"],
                    correct: 2
                },
                {
                    question: "What is the purpose of using a compass when constructing a triangle?",
                    options: ["To measure angles accurately", "To ensure all sides are equal", "To locate the exact position of the third vertex", "To check if the triangle is right-angled"],
                    correct: 2
                },
                {
                    question: "If you are given three side lengths and successfully construct a triangle, what is guaranteed?",
                    options: ["The triangle is always isosceles", "The triangle is unique", "The triangle must be a right triangle", "The triangle can have multiple possible shapes"],
                    correct: 1
                },
                {
                    question: "What happens if the sum of two given sides is exactly equal to the third side?",
                    options: ["A right triangle is formed", "A straight-line segment is formed, not a triangle", "A scalene triangle is formed", "A triangle with one 90° angle is formed"],
                    correct: 1
                },
                {
                    question: "Which of the following side lengths can form a triangle?",
                    options: ["2 cm, 3 cm, 6 cm", "5 cm, 5 cm, 10 cm", "7 cm, 8 cm, 12 cm", "4 cm, 4 cm, 9 cm"],
                    correct: 2
                },
                {
                    question: "What is the next step after drawing the longest side in triangle construction?",
                    options: ["Draw arcs from both endpoints using the other given side lengths", "Draw the other two sides without measuring", "Estimate the angles and complete the triangle", "Use a protractor to draw an angle before measuring sides"],
                    correct: 0
                },
                {
                    question: "Which triangle can be uniquely determined using just three side lengths?",
                    options: ["A right triangle", "A scalene triangle", "A triangle satisfying the triangle inequality theorem", "Any triangle with an angle sum of 180°"],
                    correct: 2
                },
                {
                    question: "Why is it important to check the triangle inequality theorem before construction?",
                    options: ["To determine if the sides will form a valid triangle", "To ensure the triangle is equilateral", "To check if the angles add up to 180°", "To confirm that one side is twice another side"],
                    correct: 0
                },
                {
                    question: "If a triangle is constructed with side lengths of 5 cm, 5 cm, and 8 cm, what type of triangle is it?",
                    options: ["Equilateral", "Isosceles", "Scalene", "Right-angled"],
                    correct: 1
                },
                {
                    question: "A real-life application of constructing triangles using given side lengths is:",
                    options: ["Estimating the area of a circle", "Designing a truss for a bridge", "Measuring time on a clock", "Constructing a rectangle"],
                    correct: 1
                },
                {
                    question: "What role does the compass play in triangle construction?",
                    options: ["It helps measure angles accurately", "It ensures the sides are parallel", "It determines the possible location of the third vertex", "It helps verify the length of the base"],
                    correct: 2
                },
                {
                    question: "A triangle has side lengths of 3 cm, 4 cm, and 5 cm. What special property does this triangle have?",
                    options: ["It is an obtuse triangle", "It is a right triangle", "It is an equilateral triangle", "It is an impossible triangle"],
                    correct: 1
                },
                {
                    question: "If a triangle has sides 6 cm, 8 cm, and 10 cm, which of the following is true?",
                    options: ["It is a right triangle", "It is an equilateral triangle", "It is impossible to construct", "It must have an obtuse angle"],
                    correct: 0
                },
                {
                    question: "If the arcs drawn from both endpoints do not intersect, what does this indicate?",
                    options: ["The given side lengths do not satisfy the triangle inequality", "The triangle is an isosceles triangle", "The triangle is obtuse", "The base length was measured incorrectly"],
                    correct: 0
                },
                {
                    question: "Which of the following errors would result in an inaccurate triangle construction?",
                    options: ["Using a compass to locate the third vertex", "Drawing the arcs too large or too small", "Checking the triangle inequality before construction", "Using a ruler to draw the base"],
                    correct: 1
                }
            ]
        };

        // Quiz variables
        let currentQuiz = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedAnswer = null;
        let quizActive = false;
        let currentLesson = 1;

        // Show lesson function
        function showLesson(lessonNum) {
            currentLesson = lessonNum;
            document.querySelectorAll('.lesson-content').forEach(lesson => {
                lesson.classList.remove('active');
            });
            document.getElementById(`lesson${lessonNum}`).classList.add('active');
            document.querySelectorAll('.lesson-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('final-score').style.display = 'none';
            quizActive = false;
            clearCanvas();
            updateGuide();
        }

        // Shuffle array function
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Start quiz function
        function startQuiz(lessonNum) {
            currentQuiz = shuffleArray(questions[lessonNum]).slice(0, 10);
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;
            quizActive = true;
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('final-score').style.display = 'none';
            showQuestion();
        }

        // Start mixed quiz function
        function startMixedQuiz() {
            const allQuestions = [...questions[1], ...questions[2], ...questions[3]];
            currentQuiz = shuffleArray(allQuestions).slice(0, 15);
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;
            quizActive = true;
            document.getElementById('quiz-container').style.display = 'block';
            document.getElementById('final-score').style.display = 'none';
            showQuestion();
        }

        // Show question function
        function showQuestion() {
            if (currentQuestionIndex >= currentQuiz.length) {
                showFinalScore();
                return;
            }

            const question = currentQuiz[currentQuestionIndex];
            const questionContainer = document.getElementById('question-container');
            questionContainer.innerHTML = `
                <div class="question-card fade-in">
                    <div class="question-number">Question ${currentQuestionIndex + 1} of ${currentQuiz.length}</div>
                    <div class="question-text">${question.question}</div>
                    <div class="options">
                        ${question.options.map((option, index) => `
                            <div class="option" onclick="selectAnswer(${index})">
                                <strong>${String.fromCharCode(65 + index)})</strong> ${option}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            document.getElementById('score-text').textContent = `Score: ${score}/${currentQuestionIndex}`;
            document.getElementById('next-btn').disabled = true;
            selectedAnswer = null;
        }

        // Select answer function
        function selectAnswer(answerIndex) {
            if (selectedAnswer !== null) return;
            selectedAnswer = answerIndex;
            const options = document.querySelectorAll('.option');
            const question = currentQuiz[currentQuestionIndex];
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === answerIndex && answerIndex !== question.correct) {
                    option.classList.add('incorrect');
                }
                option.style.pointerEvents = 'none';
            });
            if (answerIndex === question.correct) {
                score++;
            }
            document.getElementById('next-btn').disabled = false;
            setTimeout(() => {
                if (quizActive) {
                    nextQuestion();
                }
            }, 1500);
        }

        // Next question function
        function nextQuestion() {
            currentQuestionIndex++;
            showQuestion();
        }

        // Show final score function
        function showFinalScore() {
            document.getElementById('quiz-container').style.display = 'none';
            const percentage = Math.round((score / currentQuiz.length) * 100);
            let message = '';
            let emoji = '';
            if (percentage >= 90) {
                message = 'Outstanding! You are a geometry master!';
                emoji = '🏆';
            } else if (percentage >= 80) {
                message = 'Great job! You have a strong grasp of the concepts!';
                emoji = '🎉';
            } else if (percentage >= 70) {
                message = 'Good effort! Keep practicing to excel!';
                emoji = '👍';
            } else if (percentage >= 60) {
                message = 'Nice try! Review the lessons to improve!';
                emoji = '📚';
            } else {
                message = 'Keep practicing! You will get there!';
                emoji = '💪';
            }
            document.getElementById('final-score').innerHTML = `
                <div class="fade-in">
                    <h2>${emoji} Quiz Complete!</h2>
                    <p>Your Score: ${score}/${currentQuiz.length} (${percentage}%)</p>
                    <p>${message}</p>
                    <button class="quiz-btn" onclick="location.reload()" style="margin-top: 20px;">
                        🔄 Try Again
                    </button>
                </div>
            `;
            document.getElementById('final-score').style.display = 'block';
            quizActive = false;
        }

        // Canvas and construction logic
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('construction-canvas');
            const ctx = canvas.getContext('2d');
            const protractor = document.getElementById('protractor');
            const ruler = document.getElementById('ruler');
            const compass = document.getElementById('compass');
            const protractorHandle = document.getElementById('protractor-handle');
            const rulerHandle = document.getElementById('ruler-handle');
            const compassHandle = document.getElementById('compass-handle');
            const feedback = document.getElementById('feedback');
            const guide = document.getElementById('guide');

            let currentTool = 'pointer';
            let isDrawing = false;
            let startX, startY;
            let points = [];
            let lines = [];
            let arcs = [];
            let currentLine = null;
            let draggedElement = null;
            let protractorVisible = false;
            let rulerVisible = false;
            let compassVisible = false;
            let protractorAngle = 0;
            let rulerAngle = 0;
            let compassRadius = 50;
            let isRotating = false;
            let constructionStep = 0;

            // Tool buttons
            document.getElementById('pointer-btn').addEventListener('click', () => setTool('pointer'));
            document.getElementById('line-btn').addEventListener('click', () => setTool('line'));
            document.getElementById('point-btn').addEventListener('click', () => setTool('point'));
            document.getElementById('compass-btn').addEventListener('click', toggleCompass);
            document.getElementById('protractor-btn').addEventListener('click', toggleProtractor);
            document.getElementById('ruler-btn').addEventListener('click', toggleRuler);
             document.getElementById('clear-btn').addEventListener('click', clearCanvas);

            function setTool(tool) {
                currentTool = tool;
                document.querySelectorAll('.tools button').forEach(btn => {
                    btn.classList.remove('active-tool');
                    btn.classList.remove('tool-active');
                });
                document.getElementById(`${tool}-btn`).classList.add('active-tool');
                protractorHandle.style.display = 'none';
                rulerHandle.style.display = 'none';
                compassHandle.style.display = 'none';
                updateGuide();
            }

            function toggleProtractor() {
                protractorVisible = !protractorVisible;
                protractor.style.display = protractorVisible ? 'block' : 'none';
                document.getElementById('protractor-btn').classList.toggle('tool-active', protractorVisible);
                if (protractorVisible) {
                    setTool('protractor');
                    if (!protractor.style.left) {
                        const rect = canvas.getBoundingClientRect();
                        protractor.style.left = `${rect.width / 2 - 100}px`;
                        protractor.style.top = `${rect.height / 2 - 100}px`;
                    }
                    updateProtractorHandlePosition();
                    protractorHandle.style.display = 'block';
                } else {
                    setTool('pointer');
                }
                updateGuide();
            }

            function toggleRuler() {
                rulerVisible = !rulerVisible;
                ruler.style.display = rulerVisible ? 'block' : 'none';
                document.getElementById('ruler-btn').classList.toggle('tool-active', rulerVisible);
                if (rulerVisible) {
                    setTool('ruler');
                    if (!ruler.style.left) {
                        const rect = canvas.getBoundingClientRect();
                        ruler.style.left = `${rect.width / 2 - 100}px`;
                        ruler.style.top = `${rect.height / 2 - 15}px`;
                    }
                    updateRulerHandlePosition();
                    rulerHandle.style.display = 'block';
                } else {
                    setTool('pointer');
                }
                updateGuide();
            }

            function toggleCompass() {
                compassVisible = !compassVisible;
                compass.style.display = compassVisible ? 'block' : 'none';
                document.getElementById('compass-btn').classList.toggle('tool-active', compassVisible);
                if (compassVisible) {
                    setTool('compass');
                    if (!compass.style.left) {
                        const rect = canvas.getBoundingClientRect();
                        compass.style.left = `${rect.width / 2 - 10}px`;
                        compass.style.top = `${rect.height / 2 - 10}px`;
                    }
                    updateCompassHandlePosition();
                    compassHandle.style.display = 'block';
                } else {
                    setTool('pointer');
                }
                updateGuide();
            }

            function updateProtractorHandlePosition() {
                const protractorRect = protractor.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                protractorHandle.style.left = `${protractorRect.left + protractorRect.width / 2 - canvasRect.left - 5}px`;
                protractorHandle.style.top = `${protractorRect.top + protractorRect.height / 2 - canvasRect.top - 5}px`;
            }

            function updateRulerHandlePosition() {
                const rulerRect = ruler.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                rulerHandle.style.left = `${rulerRect.left + rulerRect.width / 2 - canvasRect.left - 5}px`;
                rulerHandle.style.top = `${rulerRect.top + rulerRect.height / 2 - canvasRect.top - 5}px`;
            }

            function updateCompassHandlePosition() {
                const compassRect = compass.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                compassHandle.style.left = `${compassRect.left + compassRect.width / 2 - canvasRect.left - 5}px`;
                compassHandle.style.top = `${compassRect.top + compassRect.height / 2 - canvasRect.top - 5}px`;
            }

            function updateGuide() {
                const guides = {
                    1: [
                        "Draw a line segment using the line tool and label its endpoints as A and B.",
                        "Select the compass tool and set its radius to more than half the length of AB.",
                        "Place the compass at point A and draw two arcs (above and below).",
                        "Keep the compass radius, place it at point B, and draw two intersecting arcs.",
                        "Label the intersection points as X and Y.",
                        "Draw a line through X and Y using the line tool.",
                        "Click 'Check Construction' to verify."
                    ],
                    2: [
                        "For SSS: Draw the longest side with the ruler and label it AB.",
                        "Set the compass to the second side length and draw an arc from A.",
                        "Set the compass to the third side length and draw an arc from B.",
                        "Label the intersection as C and connect A, B, C with the line tool.",
                        "For SAS: Draw a side, use the protractor at A for the angle, mark the second side with the compass, and connect.",
                        "For ASA: Draw a side, use the protractor at A and B for angles, find the rays' intersection as C, and connect."
                    ],
                    3: [
                        "Draw the longest side using the ruler and label it AB.",
                        "Set the compass to the second side length and draw an arc from A.",
                        "Set the compass to the third side length and draw an arc from B.",
                        "Label the intersection as C and connect A, B, C with the line tool.",
                        "Click 'Check Construction' to verify."
                    ]
                };
                guide.innerHTML = `<strong>Step ${constructionStep + 1}:</strong> ${guides[currentLesson][constructionStep] || "Follow the procedure steps."}`;
            }

            function clearCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                points = [];
                lines = [];
                arcs = [];
                currentLine = null;
                constructionStep = 0;
                feedback.classList.remove('show', 'success', 'error');
                feedback.innerHTML = '';
                updateGuide();
            }

            function drawPoint(x, y, label = '') {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.stroke();
                if (label) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'black';
                    ctx.fillText(label, x + 8, y + 3);
                }
            }

            function drawLine(x1, y1, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            function drawArc(x, y, radius, startAngle = 0, endAngle = Math.PI * 2) {
                ctx.beginPath();
                ctx.arc(x, y, radius, startAngle, endAngle);
                ctx.strokeStyle = 'green';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                lines.forEach(line => drawLine(line.x1, line.y1, line.x2, line.y2));
                arcs.forEach(arc => drawArc(arc.x, arc.y, arc.radius));
                points.forEach(point => drawPoint(point.x, point.y, point.label));
                if (currentLine) {
                    drawLine(currentLine.x1, currentLine.y1, currentLine.x2, currentLine.y2);
                }
            }

            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }

            function isPointNearLine(x, y, line) {
                const A = x - line.x1;
                const B = y - line.y1;
                const C = line.x2 - line.x1;
                const D = line.y2 - line.y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq !== 0) {
                    param = dot / len_sq;
                }
                let xx, yy;
                if (param < 0) {
                    xx = line.x1;
                    yy = line.y1;
                } else if (param > 1) {
                    xx = line.x2;
                    yy = line.y2;
                } else {
                    xx = line.x1 + param * C;
                    yy = line.y1 + param * D;
                }
                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy) < 10;
            }

            function isPointNearPoint(x, y, point) {
                const dx = x - point.x;
                const dy = y - point.y;
                return Math.sqrt(dx * dx + dy * dy) < 10;
            }

            function checkConstruction() {
                feedback.classList.remove('success', 'error');
                feedback.classList.add('show');
                if (currentLesson === 1) {
                    if (lines.length < 2 || points.length < 4) {
                        feedback.classList.add('error');
                        feedback.innerHTML = 'Incomplete construction. Ensure you have a segment AB, two intersection points X and Y, and a bisector line.';
                        return;
                    }
                    const segment = lines[0];
                    const bisector = lines[lines.length - 1];
                    const midX = (segment.x1 + segment.x2) / 2;
                    const midY = (segment.y1 + segment.y2) / 2;
                    const isPerpendicular = Math.abs(
                        ((bisector.x2 - bisector.x1) * (segment.x2 - segment.x1) +
                        (bisector.y2 - bisector.y1) * (segment.y2 - segment.y1)) /
                        (Math.sqrt((bisector.x2 - bisector.x1) ** 2 + (bisector.y2 - bisector.y1) ** 2) *
                        Math.sqrt((segment.x2 - segment.x1) ** 2 + (segment.y2 - segment.y1) ** 2))
                    ) < 0.1;
                    const isMidpoint = isPointNearPoint(midX, midY, {
                        x: (bisector.x1 + bisector.x2) / 2,
                        y: (bisector.y1 + bisector.y2) / 2
                    });
                    if (isPerpendicular && isMidpoint) {
                        feedback.classList.add('success');
                        feedback.innerHTML = 'Correct! The bisector is perpendicular and passes through the midpoint.';
                        constructionStep = guides[1].length - 1;
                    } else {
                        feedback.classList.add('error');
                        feedback.innerHTML = 'Incorrect. Check that the bisector is perpendicular to AB and passes through its midpoint.';
                    }
                } else if (currentLesson === 2 || currentLesson === 3) {
                    if (lines.length < 3 || points.length < 3) {
                        feedback.classList.add('error');
                        feedback.innerHTML = 'Incomplete triangle. Ensure you have three vertices (A, B, C) and three sides.';
                        return;
                    }
                    const sides = lines.slice(-3);
                    const lengths = sides.map(line => 
                        Math.sqrt((line.x2 - line.x1) ** 2 + (line.y2 - line.y1) ** 2)
                    );
                    const [a, b, c] = lengths.sort((x, y) => x - y);
                    if (a + b > c) {
                        feedback.classList.add('success');
                        feedback.innerHTML = 'Correct! The sides form a valid triangle.';
                        constructionStep = guides[currentLesson].length - 1;
                    } else {
                        feedback.classList.add('error');
                        feedback.innerHTML = 'Invalid triangle. Check the triangle inequality theorem.';
                    }
                }
                updateGuide();
            }

            canvas.addEventListener('mousedown', function (e) {
                const mousePos = getMousePos(canvas, e);
                if (currentTool === 'pointer') {
                    for (let i = 0; i < lines.length; i++) {
                        if (isPointNearLine(mousePos.x, mousePos.y, lines[i])) {
                            draggedElement = { type: 'line', index: i, offsetX: mousePos.x - lines[i].x1, offsetY: mousePos.y - lines[i].y1 };
                            return;
                        }
                    }
                    for (let i = 0; i < points.length; i++) {
                        if (isPointNearPoint(mousePos.x, mousePos.y, points[i])) {
                            draggedElement = { type: 'point', index: i };
                            return;
                        }
                    }
                }
                if (currentTool === 'line') {
                    isDrawing = true;
                    startX = mousePos.x;
                    startY = mousePos.y;
                    currentLine = { x1: startX, y1: startY, x2: startX, y2: startY };
                    constructionStep = Math.min(constructionStep + 1, guides[currentLesson].length - 1);
                    updateGuide();
                }
                if (currentTool === 'point') {
                    points.push({ x: mousePos.x, y: mousePos.y, label: String.fromCharCode(65 + points.length) });
                    redrawCanvas();
                    constructionStep = Math.min(constructionStep + 1, guides[currentLesson].length - 1);
                    updateGuide();
                }
                if (currentTool === 'protractor' && protractorVisible) {
                    const handleRect = protractorHandle.getBoundingClientRect();
                    const handleCenter = {
                        x: handleRect.left + handleRect.width / 2,
                        y: handleRect.top + handleRect.height / 2
                    };
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - handleCenter.x, 2) +
                        Math.pow(e.clientY - handleCenter.y, 2)
                    );
                    if (distance < 15) {
                        draggedElement = {
                            type: 'protractor-move',
                            startX: e.clientX,
                            startY: e.clientY,
                            initialLeft: parseInt(protractor.style.left),
                            initialTop: parseInt(protractor.style.top)
                        };
                        isRotating = false;
                    } else {
                        const protractorRect = protractor.getBoundingClientRect();
                        const protractorCenter = {
                            x: protractorRect.left + protractorRect.width / 2,
                            y: protractorRect.top + protractorRect.height / 2
                        };
                        const angle = Math.atan2(
                            e.clientY - protractorCenter.y,
                            e.clientX - protractorCenter.x
                        );
                        draggedElement = {
                            type: 'protractor-rotate',
                            startAngle: angle,
                            initialRotation: protractorAngle
                        };
                        isRotating = true;
                    }
                }
                if (currentTool === 'ruler' && rulerVisible) {
                    const handleRect = rulerHandle.getBoundingClientRect();
                    const handleCenter = {
                        x: handleRect.left + handleRect.width / 2,
                        y: handleRect.top + handleRect.height / 2
                    };
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - handleCenter.x, 2) +
                        Math.pow(e.clientY - handleCenter.y, 2)
                    );
                    if (distance < 15) {
                        draggedElement = {
                            type: 'ruler-move',
                            startX: e.clientX,
                            startY: e.clientY,
                            initialLeft: parseInt(ruler.style.left),
                            initialTop: parseInt(ruler.style.top)
                        };
                        isRotating = false;
                    } else {
                        const rulerRect = ruler.getBoundingClientRect();
                        const rulerCenter = {
                            x: rulerRect.left + rulerRect.width / 2,
                            y: rulerRect.top + rulerRect.height / 2
                        };
                        const angle = Math.atan2(
                            e.clientY - rulerCenter.y,
                            e.clientX - rulerCenter.x
                        );
                        draggedElement = {
                            type: 'ruler-rotate',
                            startAngle: angle,
                            initialRotation: rulerAngle
                        };
                        isRotating = true;
                    }
                }
                if (currentTool === 'compass' && compassVisible) {
                    const handleRect = compassHandle.getBoundingClientRect();
                    const handleCenter = {
                        x: handleRect.left + handleRect.width / 2,
                        y: handleRect.top + handleRect.height / 2
                    };
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - handleCenter.x, 2) +
                        Math.pow(e.clientY - handleCenter.y, 2)
                    );
                    if (distance < 15) {
                        draggedElement = {
                            type: 'compass-move',
                            startX: e.clientX,
                            startY: e.clientY,
                            initialLeft: parseInt(compass.style.left),
                            initialTop: parseInt(compass.style.top)
                        };
                    } else {
                        const compassRect = compass.getBoundingClientRect();
                        const compassCenter = {
                            x: compassRect.left + compassRect.width / 2,
                            y: compassRect.top + compassRect.height / 2
                        };
                        compassRadius = Math.sqrt(
                            Math.pow(e.clientX - compassCenter.x, 2) +
                            Math.pow(e.clientY - compassCenter.y, 2)
                        );
                        compass.style.width = `${compassRadius * 2}px`;
                        compass.style.height = `${compassRadius * 2}px`;
                        compass.style.left = `${parseInt(compass.style.left) - (compassRadius - 10)}px`;
                        compass.style.top = `${parseInt(compass.style.top) - (compassRadius - 10)}px`;
                        updateCompassHandlePosition();
                        arcs.push({ x: parseInt(compass.style.left) + compassRadius, y: parseInt(compass.style.top) + compassRadius, radius: compassRadius });
                        redrawCanvas();
                        constructionStep = Math.min(constructionStep + 1, guides[currentLesson].length - 1);
                        updateGuide();
                    }
                }
            });

            canvas.addEventListener('mousemove', function (e) {
                const mousePos = getMousePos(canvas, e);
                if (currentTool === 'pointer' && draggedElement) {
                    if (draggedElement.type === 'line') {
                        const line = lines[draggedElement.index];
                        const dx = mousePos.x - draggedElement.offsetX - line.x1;
                        const dy = mousePos.y - draggedElement.offsetY - line.y1;
                        line.x1 += dx;
                        line.y1 += dy;
                        line.x2 += dx;
                        line.y2 += dy;
                        redrawCanvas();
                    } else if (draggedElement.type === 'point') {
                        points[draggedElement.index].x = mousePos.x;
                        points[draggedElement.index].y = mousePos.y;
                        redrawCanvas();
                    }
                    return;
                }
                if (currentTool === 'line' && isDrawing) {
                    currentLine.x2 = mousePos.x;
                    currentLine.y2 = mousePos.y;
                    redrawCanvas();
                }
                if (currentTool === 'protractor' && protractorVisible && draggedElement) {
                    if (draggedElement.type === 'protractor-move') {
                        const dx = e.clientX - draggedElement.startX;
                        const dy = e.clientY - draggedElement.startY;
                        protractor.style.left = `${draggedElement.initialLeft + dx}px`;
                        protractor.style.top = `${draggedElement.initialTop + dy}px`;
                        updateProtractorHandlePosition();
                    } else if (draggedElement.type === 'protractor-rotate') {
                        const protractorRect = protractor.getBoundingClientRect();
                        const protractorCenter = {
                            x: protractorRect.left + protractorRect.width / 2,
                            y: protractorRect.top + protractorRect.height / 2
                        };
                        const currentAngle = Math.atan2(
                            e.clientY - protractorCenter.y,
                            e.clientX - protractorCenter.x
                        );
                        const angleDiff = currentAngle - draggedElement.startAngle;
                        protractorAngle = draggedElement.initialRotation + angleDiff * (180 / Math.PI);
                        protractor.style.transform = `rotate(${protractorAngle}deg)`;
                        updateProtractorHandlePosition();
                    }
                }
                if (currentTool === 'ruler' && rulerVisible && draggedElement) {
                    if (draggedElement.type === 'ruler-move') {
                        const dx = e.clientX - draggedElement.startX;
                        const dy = e.clientY - draggedElement.startY;
                        ruler.style.left = `${draggedElement.initialLeft + dx}px`;
                        ruler.style.top = `${draggedElement.initialTop + dy}px`;
                        updateRulerHandlePosition();
                    } else if (draggedElement.type === 'ruler-rotate') {
                        const rulerRect = ruler.getBoundingClientRect();
                        const rulerCenter = {
                            x: rulerRect.left + rulerRect.width / 2,
                            y: rulerRect.top + rulerRect.height / 2
                        };
                        const currentAngle = Math.atan2(
                            e.clientY - rulerCenter.y,
                            e.clientX - rulerCenter.x
                        );
                        const angleDiff = currentAngle - draggedElement.startAngle;
                        rulerAngle = draggedElement.initialRotation + angleDiff * (180 / Math.PI);
                        ruler.style.transform = `rotate(${rulerAngle}deg)`;
                        updateRulerHandlePosition();
                    }
                }
                if (currentTool === 'compass' && compassVisible && draggedElement && draggedElement.type === 'compass-move') {
                    const dx = e.clientX - draggedElement.startX;
                    const dy = e.clientY - draggedElement.startY;
                    compass.style.left = `${draggedElement.initialLeft + dx}px`;
                    compass.style.top = `${draggedElement.initialTop + dy}px`;
                    updateCompassHandlePosition();
                }
            });

            canvas.addEventListener('mouseup', function (e) {
                const mousePos = getMousePos(canvas, e);
                if (currentTool === 'pointer' && draggedElement) {
                    draggedElement = null;
                    return;
                }
                if (currentTool === 'line' && isDrawing) {
                    isDrawing = false;
                    lines.push(currentLine);
                    currentLine = null;
                    redrawCanvas();
                }
                if ((currentTool === 'protractor' || currentTool === 'ruler' || currentTool === 'compass') && draggedElement) {
                    draggedElement = null;
                    isRotating = false;
                }
            });

            document.addEventListener('keydown', function (e) {
                if (e.key === 'Escape') {
                    if (protractorVisible) toggleProtractor();
                    if (rulerVisible) toggleRuler();
                    if (compassVisible) toggleCompass();
                }
            });

            // Initialize
            setTool('pointer');
            updateGuide();

            // Animation observer
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('fade-in');
                    }
                });
            });
            document.querySelectorAll('.procedure-section, .activity-section').forEach(section => {
                observer.observe(section);
            });
        });
    </script>
</body>
</html>